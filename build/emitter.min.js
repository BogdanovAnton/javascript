var mqtt=require("mqtt");module.exports=function(){var Emitter=function(){function Emitter(){}return Emitter.prototype.$id=function(){var d=(new Date).getTime(),uuid="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(c){var r=(d+16*Math.random())%16|0;return d=Math.floor(d/16),("x"==c?r:3&r|8).toString(16)});return uuid},Emitter.prototype.$onConnect=function(){this.$tryInvoke("connect",this)},Emitter.prototype.$onDisconnect=function(){this.$tryInvoke("disconnect",this)},Emitter.prototype.$tryInvoke=function(name,args){var callback=this.$callbacks[name];return"undefined"!=typeof callback&&null!==callback?void callback(args):void 0},Emitter.prototype.$startsWith=function(text,prefix){return text.slice(0,prefix.length)==prefix},Emitter.prototype.connect=function(host,port){var _this=this;void 0==host&&(host="api.emitter.io"),void 0==port&&(port=8080),this.$callbacks={},this.$mqtt=mqtt.connect({port:port,host:host,keepalive:1e4,clientId:this.$id}),this.$mqtt.on("connect",function(){_this.$onConnect()}),this.$mqtt.on("close",function(){_this.$onDisconnect()}),this.$mqtt.on("offline",function(){_this.$onDisconnect()}),this.$mqtt.on("message",function(topic,msg,packet){var message=new EmitterMessage(packet);_this.$startsWith(message.channel,"emitter/keygen")?_this.$tryInvoke("keygen",message.asObject()):_this.$tryInvoke("message",message)})},Emitter.prototype.publish=function(request){"string"!=typeof request.key&&this.logError("emitter.publish: request object does not contain a 'key' string."),"string"!=typeof request.channel&&this.logError("emitter.publish: request object does not contain a 'channel' string."),"object"!=typeof request.message&&"string"!=typeof request.message&&this.logError("emitter.publish: request object does not contain a 'message' object.");var topic=request.key+"/"+request.channel;this.$mqtt.publish(topic,request.message)},Emitter.prototype.subscribe=function(request){"string"!=typeof request.key&&this.logError("emitter.subscribe: request object does not contain a 'key' string."),"string"!=typeof request.channel&&this.logError("emitter.subscribe: request object does not contain a 'channel' string."),this.$mqtt.subscribe(request.key+"/"+request.channel)},Emitter.prototype.unsubscribe=function(request){"string"!=typeof request.key&&this.logError("emitter.unsubscribe: request object does not contain a 'key' string."),"string"!=typeof request.channel&&this.logError("emitter.unsubscribe: request object does not contain a 'channel' string."),this.$mqtt.unsubscribe(request.key+"/"+request.channel)},Emitter.prototype.keygen=function(request){"string"!=typeof request.key&&this.logError("emitter.keygen: request object does not contain a 'key' string."),"string"!=typeof request.channel&&this.logError("emitter.keygen: request object does not contain a 'channel' string."),this.$mqtt.publish("emitter/keygen/",JSON.stringify(request))},Emitter.prototype.on=function(event,callback){switch(event){case"connect":case"disconnect":case"message":case"keygen":break;default:this.logError("emitter.on: unknown event type, supported values are 'connect', 'disconnect', 'message' and 'keygen'.")}this.$callbacks[event]=callback},Emitter.prototype.logError=function(message){throw console.error(message),new Error(message)},Emitter}(),EmitterMessage=function(){function EmitterMessage(m){this.channel=m.topic,this.binary=m.payload}return EmitterMessage.prototype.asString=function(){return this.binary.toString()},EmitterMessage.prototype.asBinary=function(){return this.binary},EmitterMessage.prototype.asObject=function(){return JSON.parse(this.asString())},EmitterMessage}();return new Emitter};